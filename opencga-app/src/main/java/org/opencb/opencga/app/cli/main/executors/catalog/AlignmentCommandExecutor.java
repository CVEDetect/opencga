/*
* Copyright 2015-2021 OpenCB
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

package org.opencb.opencga.app.cli.main.executors.catalog;

import org.opencb.opencga.app.cli.main.executors.OpencgaCommandExecutor;
import org.opencb.opencga.core.response.RestResponse;
import org.ga4gh.models.ReadAlignment;
import org.opencb.biodata.models.alignment.GeneCoverageStats;
import org.opencb.biodata.models.alignment.RegionCoverage;
import org.opencb.opencga.app.cli.main.options.AlignmentCommandOptions;
import org.opencb.opencga.client.exceptions.ClientException;
import org.opencb.opencga.core.models.alignment.AlignmentGeneCoverageStatsParams;
import org.opencb.opencga.core.models.alignment.AlignmentIndexParams;
import org.opencb.opencga.core.models.alignment.AlignmentQcParams;
import org.opencb.opencga.core.models.alignment.BwaWrapperParams;
import org.opencb.opencga.core.models.alignment.CoverageIndexParams;
import org.opencb.opencga.core.models.alignment.DeeptoolsWrapperParams;
import org.opencb.opencga.core.models.alignment.FastqcWrapperParams;
import org.opencb.opencga.core.models.alignment.PicardWrapperParams;
import org.opencb.opencga.core.models.alignment.SamtoolsWrapperParams;
import org.opencb.opencga.core.models.job.Job;


/*
* WARNING: AUTOGENERATED CODE
*
* This code was generated by a tool.
* Autogenerated on: 2021-08-05 17:10:13
*
* Manual changes to this file may cause unexpected behavior in your application.
* Manual changes to this file will be overwritten if the code is regenerated.
*/

public class AlignmentCommandExecutor extends OpencgaCommandExecutor {

    private AlignmentCommandOptions alignmentCommandOptions;

    public AlignmentCommandExecutor(AlignmentCommandOptions alignmentCommandOptions) {
        super(alignmentCommandOptions.commonCommandOptions);
        this.alignmentCommandOptions = alignmentCommandOptions;
    }

    @Override
    public void execute() throws Exception {
        logger.debug("Executing Analysis - Alignment command line");
        
        String subCommandString = getParsedSubCommand(alignmentCommandOptions.jCommander);
        RestResponse queryResponse = null;
        switch (subCommandString) {
            case "runBwa":
                queryResponse = runBwa();
                break;
            case "runCoverageIndex":
                queryResponse = runCoverageIndex();
                break;
            case "runQcGeneCoverageStats":
                queryResponse = runQcGeneCoverageStats();
                break;
            case "queryCoverage":
                queryResponse = queryCoverage();
                break;
            case "ratioCoverage":
                queryResponse = ratioCoverage();
                break;
            case "statsCoverage":
                queryResponse = statsCoverage();
                break;
            case "runDeeptools":
                queryResponse = runDeeptools();
                break;
            case "runFastqc":
                queryResponse = runFastqc();
                break;
            case "runIndex":
                queryResponse = runIndex();
                break;
            case "runPicard":
                queryResponse = runPicard();
                break;
            case "runQc":
                queryResponse = runQc();
                break;
            case "query":
                queryResponse = query();
                break;
            case "runSamtools":
                queryResponse = runSamtools();
                break;
            default:
                logger.error("Subcommand not valid");
                 break;
        }
    
        createOutput(queryResponse);
    
    }
    

    private RestResponse<Job> runBwa() throws ClientException {
        logger.debug("Executing runBwa in Alignment command line");

        AlignmentCommandOptions.RunBwaCommandOptions commandOptions = alignmentCommandOptions.runBwaCommandOptions;

        ObjectMap queryParams = new ObjectMap();
        queryParams.putIfNotEmpty("study", commandOptions.study);
        queryParams.putIfNotEmpty("jobId", commandOptions.jobId);
        queryParams.putIfNotEmpty("jobDependsOn", commandOptions.jobDependsOn);
        queryParams.putIfNotEmpty("jobDescription", commandOptions.jobDescription);
        queryParams.putIfNotEmpty("jobTags", commandOptions.jobTags);

        BwaWrapperParams bwaWrapperParams = new BwaWrapperParams()
                .setDESCRIPTION(commandOptions.DESCRIPTION)
                .setCommand(commandOptions.command)
                .setFastaFile(commandOptions.fastaFile)
                .setFastq1File(commandOptions.fastq1File)
                .setFastq2File(commandOptions.fastq2File)
                .setOutdir(commandOptions.outdir);

        return openCGAClient.getAlignmentClient().runBwa(bwaWrapperParams, queryParams);
    }
    
    private RestResponse<Job> runCoverageIndex() throws ClientException {
        logger.debug("Executing runCoverageIndex in Alignment command line");

        AlignmentCommandOptions.RunCoverageIndexCommandOptions commandOptions = alignmentCommandOptions.runCoverageIndexCommandOptions;

        ObjectMap queryParams = new ObjectMap();
        queryParams.putIfNotEmpty("study", commandOptions.study);
        queryParams.putIfNotEmpty("jobId", commandOptions.jobId);
        queryParams.putIfNotEmpty("jobDependsOn", commandOptions.jobDependsOn);
        queryParams.putIfNotEmpty("jobDescription", commandOptions.jobDescription);
        queryParams.putIfNotEmpty("jobTags", commandOptions.jobTags);

        CoverageIndexParams coverageIndexParams = new CoverageIndexParams()
                .setDESCRIPTION(commandOptions.DESCRIPTION)
                .setFile(commandOptions.file)
                .setWindowSize(commandOptions.windowSize)
                .setOverwrite(commandOptions.overwrite);

        return openCGAClient.getAlignmentClient().runCoverageIndex(coverageIndexParams, queryParams);
    }
    
    private RestResponse<Job> runQcGeneCoverageStats() throws ClientException {
        logger.debug("Executing runQcGeneCoverageStats in Alignment command line");

        AlignmentCommandOptions.RunQcGeneCoverageStatsCommandOptions commandOptions = alignmentCommandOptions.runQcGeneCoverageStatsCommandOptions;

        ObjectMap queryParams = new ObjectMap();
        queryParams.putIfNotEmpty("study", commandOptions.study);
        queryParams.putIfNotEmpty("jobId", commandOptions.jobId);
        queryParams.putIfNotEmpty("jobDependsOn", commandOptions.jobDependsOn);
        queryParams.putIfNotEmpty("jobDescription", commandOptions.jobDescription);
        queryParams.putIfNotEmpty("jobTags", commandOptions.jobTags);

        AlignmentGeneCoverageStatsParams alignmentGeneCoverageStatsParams = new AlignmentGeneCoverageStatsParams()
                .setDESCRIPTION(commandOptions.DESCRIPTION)
                .setBamFile(commandOptions.bamFile)
                .setOutdir(commandOptions.outdir);

        return openCGAClient.getAlignmentClient().runQcGeneCoverageStats(alignmentGeneCoverageStatsParams, queryParams);
    }
    
    private RestResponse<RegionCoverage> queryCoverage() throws ClientException {
        logger.debug("Executing queryCoverage in Alignment command line");

        AlignmentCommandOptions.QueryCoverageCommandOptions commandOptions = alignmentCommandOptions.queryCoverageCommandOptions;

        ObjectMap queryParams = new ObjectMap();
        queryParams.putIfNotEmpty("study", commandOptions.study);
        queryParams.putIfNotEmpty("region", commandOptions.region);
        queryParams.putIfNotEmpty("gene", commandOptions.gene);
        queryParams.putIfNotNull("offset", commandOptions.offset);
        queryParams.putIfNotNull("onlyExons", commandOptions.onlyExons);
        queryParams.putIfNotEmpty("range", commandOptions.range);
        queryParams.putIfNotNull("windowSize", commandOptions.windowSize);
        queryParams.putIfNotNull("splitResults", commandOptions.splitResults);

        return openCGAClient.getAlignmentClient().queryCoverage(commandOptions.file.name(), queryParams);
    }
    
    private RestResponse<RegionCoverage> ratioCoverage() throws ClientException {
        logger.debug("Executing ratioCoverage in Alignment command line");

        AlignmentCommandOptions.RatioCoverageCommandOptions commandOptions = alignmentCommandOptions.ratioCoverageCommandOptions;

        ObjectMap queryParams = new ObjectMap();
        queryParams.putIfNotEmpty("study", commandOptions.study);
        queryParams.putIfNotNull("skipLog2", commandOptions.skipLog2);
        queryParams.putIfNotEmpty("region", commandOptions.region);
        queryParams.putIfNotEmpty("gene", commandOptions.gene);
        queryParams.putIfNotNull("offset", commandOptions.offset);
        queryParams.putIfNotNull("onlyExons", commandOptions.onlyExons);
        queryParams.putIfNotNull("windowSize", commandOptions.windowSize);
        queryParams.putIfNotNull("splitResults", commandOptions.splitResults);

        return openCGAClient.getAlignmentClient().ratioCoverage(commandOptions.file1.name(),commandOptions.file2.name(), queryParams);
    }
    
    private RestResponse<GeneCoverageStats> statsCoverage() throws ClientException {
        logger.debug("Executing statsCoverage in Alignment command line");

        AlignmentCommandOptions.StatsCoverageCommandOptions commandOptions = alignmentCommandOptions.statsCoverageCommandOptions;

        ObjectMap queryParams = new ObjectMap();
        queryParams.putIfNotEmpty("study", commandOptions.study);
        queryParams.putIfNotNull("threshold", commandOptions.threshold);

        return openCGAClient.getAlignmentClient().statsCoverage(commandOptions.file.name(),commandOptions.gene.name(), queryParams);
    }
    
    private RestResponse<Job> runDeeptools() throws ClientException {
        logger.debug("Executing runDeeptools in Alignment command line");

        AlignmentCommandOptions.RunDeeptoolsCommandOptions commandOptions = alignmentCommandOptions.runDeeptoolsCommandOptions;

        ObjectMap queryParams = new ObjectMap();
        queryParams.putIfNotEmpty("study", commandOptions.study);
        queryParams.putIfNotEmpty("jobId", commandOptions.jobId);
        queryParams.putIfNotEmpty("jobDependsOn", commandOptions.jobDependsOn);
        queryParams.putIfNotEmpty("jobDescription", commandOptions.jobDescription);
        queryParams.putIfNotEmpty("jobTags", commandOptions.jobTags);

        DeeptoolsWrapperParams deeptoolsWrapperParams = new DeeptoolsWrapperParams()
                .setDESCRIPTION(commandOptions.DESCRIPTION)
                .setCommand(commandOptions.command)
                .setOutdir(commandOptions.outdir);

        return openCGAClient.getAlignmentClient().runDeeptools(deeptoolsWrapperParams, queryParams);
    }
    
    private RestResponse<Job> runFastqc() throws ClientException {
        logger.debug("Executing runFastqc in Alignment command line");

        AlignmentCommandOptions.RunFastqcCommandOptions commandOptions = alignmentCommandOptions.runFastqcCommandOptions;

        ObjectMap queryParams = new ObjectMap();
        queryParams.putIfNotEmpty("study", commandOptions.study);
        queryParams.putIfNotEmpty("jobId", commandOptions.jobId);
        queryParams.putIfNotEmpty("jobDependsOn", commandOptions.jobDependsOn);
        queryParams.putIfNotEmpty("jobDescription", commandOptions.jobDescription);
        queryParams.putIfNotEmpty("jobTags", commandOptions.jobTags);

        FastqcWrapperParams fastqcWrapperParams = new FastqcWrapperParams()
                .setDESCRIPTION(commandOptions.DESCRIPTION)
                .setInputFile(commandOptions.inputFile)
                .setOutdir(commandOptions.outdir);

        return openCGAClient.getAlignmentClient().runFastqc(fastqcWrapperParams, queryParams);
    }
    
    private RestResponse<Job> runIndex() throws ClientException {
        logger.debug("Executing runIndex in Alignment command line");

        AlignmentCommandOptions.RunIndexCommandOptions commandOptions = alignmentCommandOptions.runIndexCommandOptions;

        ObjectMap queryParams = new ObjectMap();
        queryParams.putIfNotEmpty("study", commandOptions.study);
        queryParams.putIfNotEmpty("jobId", commandOptions.jobId);
        queryParams.putIfNotEmpty("jobDependsOn", commandOptions.jobDependsOn);
        queryParams.putIfNotEmpty("jobDescription", commandOptions.jobDescription);
        queryParams.putIfNotEmpty("jobTags", commandOptions.jobTags);

        AlignmentIndexParams alignmentIndexParams = new AlignmentIndexParams()
                .setDESCRIPTION(commandOptions.DESCRIPTION)
                .setFile(commandOptions.file)
                .setOverwrite(commandOptions.overwrite);

        return openCGAClient.getAlignmentClient().runIndex(alignmentIndexParams, queryParams);
    }
    
    private RestResponse<Job> runPicard() throws ClientException {
        logger.debug("Executing runPicard in Alignment command line");

        AlignmentCommandOptions.RunPicardCommandOptions commandOptions = alignmentCommandOptions.runPicardCommandOptions;

        ObjectMap queryParams = new ObjectMap();
        queryParams.putIfNotEmpty("study", commandOptions.study);
        queryParams.putIfNotEmpty("jobId", commandOptions.jobId);
        queryParams.putIfNotEmpty("jobDependsOn", commandOptions.jobDependsOn);
        queryParams.putIfNotEmpty("jobDescription", commandOptions.jobDescription);
        queryParams.putIfNotEmpty("jobTags", commandOptions.jobTags);

        PicardWrapperParams picardWrapperParams = new PicardWrapperParams()
                .setDESCRIPTION(commandOptions.DESCRIPTION)
                .setCommand(commandOptions.command)
                .setOutdir(commandOptions.outdir);

        return openCGAClient.getAlignmentClient().runPicard(picardWrapperParams, queryParams);
    }
    
    private RestResponse<Job> runQc() throws ClientException {
        logger.debug("Executing runQc in Alignment command line");

        AlignmentCommandOptions.RunQcCommandOptions commandOptions = alignmentCommandOptions.runQcCommandOptions;

        ObjectMap queryParams = new ObjectMap();
        queryParams.putIfNotEmpty("study", commandOptions.study);
        queryParams.putIfNotEmpty("jobId", commandOptions.jobId);
        queryParams.putIfNotEmpty("jobDependsOn", commandOptions.jobDependsOn);
        queryParams.putIfNotEmpty("jobDescription", commandOptions.jobDescription);
        queryParams.putIfNotEmpty("jobTags", commandOptions.jobTags);

        AlignmentQcParams alignmentQcParams = new AlignmentQcParams()
                .setSTATS_SKIP_VALUE(commandOptions.STATS_SKIP_VALUE)
                .setFLAGSTATS_SKIP_VALUE(commandOptions.FLAGSTATS_SKIP_VALUE)
                .setFASTQC_METRICS_SKIP_VALUE(commandOptions.FASTQC_METRICS_SKIP_VALUE)
                .setHS_METRICS_SKIP_VALUE(commandOptions.HS_METRICS_SKIP_VALUE)
                .setDESCRIPTION(commandOptions.DESCRIPTION)
                .setBamFile(commandOptions.bamFile)
                .setBedFile(commandOptions.bedFile)
                .setDictFile(commandOptions.dictFile)
                .setSkip(commandOptions.skip)
                .setOverwrite(commandOptions.overwrite)
                .setOutdir(commandOptions.outdir);

        return openCGAClient.getAlignmentClient().runQc(alignmentQcParams, queryParams);
    }
    
    private RestResponse<ReadAlignment> query() throws ClientException {
        logger.debug("Executing query in Alignment command line");

        AlignmentCommandOptions.QueryCommandOptions commandOptions = alignmentCommandOptions.queryCommandOptions;

        ObjectMap queryParams = new ObjectMap();
        queryParams.putIfNotNull("count", commandOptions.count);
        queryParams.putIfNotEmpty("study", commandOptions.study);
        queryParams.putIfNotEmpty("region", commandOptions.region);
        queryParams.putIfNotEmpty("gene", commandOptions.gene);
        queryParams.putIfNotNull("offset", commandOptions.offset);
        queryParams.putIfNotNull("onlyExons", commandOptions.onlyExons);
        queryParams.putIfNotNull("properlyPaired", commandOptions.properlyPaired);
        queryParams.putIfNotNull("skipUnmapped", commandOptions.skipUnmapped);
        queryParams.putIfNotNull("skipDuplicated", commandOptions.skipDuplicated);
        queryParams.putIfNotNull("regionContained", commandOptions.regionContained);
        queryParams.putIfNotNull("forceMDField", commandOptions.forceMDField);
        queryParams.putIfNotNull("binQualities", commandOptions.binQualities);
        queryParams.putIfNotNull("splitResults", commandOptions.splitResults);

        return openCGAClient.getAlignmentClient().query(commandOptions.file.name(), queryParams);
    }
    
    private RestResponse<Job> runSamtools() throws ClientException {
        logger.debug("Executing runSamtools in Alignment command line");

        AlignmentCommandOptions.RunSamtoolsCommandOptions commandOptions = alignmentCommandOptions.runSamtoolsCommandOptions;

        ObjectMap queryParams = new ObjectMap();
        queryParams.putIfNotEmpty("study", commandOptions.study);
        queryParams.putIfNotEmpty("jobId", commandOptions.jobId);
        queryParams.putIfNotEmpty("jobDependsOn", commandOptions.jobDependsOn);
        queryParams.putIfNotEmpty("jobDescription", commandOptions.jobDescription);
        queryParams.putIfNotEmpty("jobTags", commandOptions.jobTags);

        SamtoolsWrapperParams samtoolsWrapperParams = new SamtoolsWrapperParams()
                .setDESCRIPTION(commandOptions.DESCRIPTION)
                .setCommand(commandOptions.command)
                .setInputFile(commandOptions.inputFile)
                .setOutdir(commandOptions.outdir);

        return openCGAClient.getAlignmentClient().runSamtools(samtoolsWrapperParams, queryParams);
    }
    
}
