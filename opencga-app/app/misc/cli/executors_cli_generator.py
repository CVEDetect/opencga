#!/usr/bin/env python3

import re
import sys
# importing date class from datetime module
from datetime import date

from cli_generator import RestClientGenerator


class ExecutorCliGenerator(RestClientGenerator):

    def __init__(self):
        super().__init__()

        self.java_types = set()
        self.type_imports = {
            'ObjectMap': 'org.opencb.commons.datastore.core.ObjectMap;'
        }

        self.ignore_types = [
            'Integer', 'String', 'boolean', 'int', 'Boolean'
        ]

        self.param_types = {
            'string': 'String',
            'object': 'Object',
            'integer': 'int',
            'int': 'int',
            'map': 'ObjectMap',
            'boolean': 'boolean',
            'enum': 'String',
            'long': 'Long',
            'java.lang.String': 'String',
            'java.lang.Boolean': 'boolean',
            'java.lang.Integer': 'int',
            'java.lang.Long': 'int',
            'java.lang.Short': 'int',
            'java.lang.Double': 'int',
            'java.lang.Float': 'int'
        }
        self.output_dir = self.executors_output_dir
        self.imports = []

    def get_imports(self):
        headers = []
        headers.append('/*')
        headers.append('* Copyright 2015-{} OpenCB'.format(date.today().year))
        headers.append('*')
        headers.append('* Licensed under the Apache License, Version 2.0 (the "License");')
        headers.append('* you may not use this file except in compliance with the License.')
        headers.append('* You may obtain a copy of the License at')
        headers.append('*')
        headers.append('*     http://www.apache.org/licenses/LICENSE-2.0')
        headers.append('*')
        headers.append('* Unless required by applicable law or agreed to in writing, software')
        headers.append('* distributed under the License is distributed on an "AS IS" BASIS,')
        headers.append('* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.')
        headers.append('* See the License for the specific language governing permissions and')
        headers.append('* limitations under the License.')
        headers.append('*/')
        headers.append('')
        headers.append('package org.opencb.opencga.app.cli.main.executors.catalog;')
        headers.append('')
        imports = set()
        for java_type in self.java_types:
            if java_type in self.type_imports and java_type not in self.ignore_types:
                imports.add(self.type_imports[java_type])
            elif java_type not in self.ignore_types:
                raise Exception(java_type + ' not found')

        imports = remove_redundant_imports(list(imports))
        imports.sort()

        autogenerated_message = []
        autogenerated_message.append('/*')
        for text in self.get_autogenerated_message():
            if text == '':
                autogenerated_message.append('*')
            else:
                autogenerated_message.append('* ' + text)
        autogenerated_message.append('*/')

        return '\n'.join(headers) + '\n' + '\n'.join(['import ' + i for i in imports]) + '\n\n\n' + '\n'.join(autogenerated_message)

    def get_class_definition(self, category):
        self.java_types = set()
        self.imports = []
        class_attributes = {}
        for endpoint in category["endpoints"]:
            class_attributes[endpoint["path"]] = self.get_method_name(endpoint, category)

        text = []
        '''
        text.append('import com.fasterxml.jackson.databind.ObjectMapper;')
        text.append('import org.opencb.commons.datastore.core.FacetField;')
        text.append('import org.opencb.commons.datastore.core.ObjectMap;')
        text.append('import org.opencb.commons.datastore.core.QueryOptions;')
        text.append('import org.opencb.opencga.app.cli.main.executors.OpencgaCommandExecutor;')
        text.append('import org.opencb.opencga.app.cli.main.options.{}CommandOptions;'.format(self.categories[category['name']]))
        text.append('import org.opencb.opencga.app.cli.main.options.commons.AclCommandOptions;')
        text.append('import org.opencb.opencga.app.cli.main.options.commons.AnnotationCommandOptions;')
        text.append('import org.opencb.opencga.catalog.db.api.{}DBAdaptor;'.format(self.categories[category['name']]))
        text.append('import org.opencb.opencga.catalog.exceptions.CatalogException;')
        text.append('import org.opencb.opencga.catalog.utils.Constants;')
        text.append('import org.opencb.opencga.client.exceptions.ClientException;')
        text.append('import org.opencb.opencga.core.api.ParamConstants;')
        text.append('import org.opencb.opencga.core.models.sample.{};'.format(self.categories[category['name']]))
        text.append('import org.opencb.opencga.core.models.sample.{}AclUpdateParams;'.format(self.categories[category['name']]))
        text.append('import org.opencb.opencga.core.models.sample.{}CreateParams;'.format(self.categories[category['name']]))
        text.append('import org.opencb.opencga.core.models.sample.{}UpdateParams;'.format(self.categories[category['name']]))
        text.append('import org.opencb.opencga.core.response.RestResponse;')
        text.append('')
        text.append('import java.io.File;')
        text.append('import java.io.IOException;')
        text.append('')
        text.append('/**')
        text.append(' * Created by opencb on {}/{}/{}.'.format(date.today().day, date.today().month, date.today().year))
        text.append(' */')
        text.append('public class {}CommandExecutor extends OpencgaCommandExecutor {{'.format(self.categories[category['name']]))
        text.append('')
        text.append('    private {}CommandOptions {}CommandOptions;'.format(self.categories[category['name']], category['name'].lower()))
        text.append('')
        text.append('    public {}CommandExecutor({}CommandOptions {}CommandOptions) {{'.format(self.categories[category['name']],
                                                                                                self.categories[category['name']],
                                                                                                category['name'].lower()))
        text.append('        super({}CommandOptions.commonCommandOptions);'.format(category['name'].lower()))
        text.append('        this.{}CommandOptions = {}CommandOptions;'.format(category['name'].lower(), category['name'].lower()))
        text.append('    }')
        text.append('')
        text.append('')
        text.append('    @Override')
        text.append('    public void execute() throws Exception {')
        text.append('        logger.debug("Executing {} command line");'.format(category['name'].lower()))
        text.append('')
        text.append('        String subCommandString = getParsedSubCommand({}CommandOptions.jCommander);'.format(category['name'].lower()))
        text.append('        RestResponse queryResponse = null;')
        text.append('        switch (subCommandString) {')
        for endpoint in category["endpoints"]:
            text.append('            case "{}":'.format(self.to_kebab_case(self.get_method_name(endpoint, category).replace('.', '-'))))
            text.append('                queryResponse = {}();'.format(self.get_method_name(endpoint, category)))
            text.append('                break;')

        text.append('            default:')
        text.append('                logger.error("Subcommand not valid");')
        text.append('                break;')
        text.append('        }')
        text.append('')
        text.append('        createOutput(queryResponse);')
        text.append('    }')
        '''
        text.append('')

        return '\n'.join(text)

    def get_class_end(self):
        return '}\n'

    def get_method_definition(self, category, endpoint):
        method_name = self.get_method_name(endpoint, category).lower()
        self.get_valid_parameter_type(self.get_endpoint_response(endpoint), self.get_endpoint_response_class(endpoint))
        if self.check_ignore_command(category["name"], method_name):
            parameters = self.get_method_parameters(endpoint)
            for parameter in parameters:
                name = self.normalize_names(parameter["name"])
                if name == 'body':
                    if "data" in parameter.keys():
                        data = parameter["data"]
                        for item in data:
                            self.get_valid_parameter_type(item["type"], item["typeClass"])

                self.get_valid_parameter_type(parameter["type"], parameter["typeClass"])
        return ' '
        '''
        if self.check_ignore_command(category["name"], method_name):
            parameters = self.get_method_parameters(endpoint)
            text = []
            self.append_command(text, self.to_kebab_case(self.get_method_name(endpoint, category)),
                                self.get_endpoint_description(endpoint))
            append_text(text, '{}public class {}CommandOptions {{'.format((' ' * 4), self.get_as_class_name(self.get_method_name(endpoint,
                                                                                                                                 category))),
                        5)
            text.append('{}'.format(' ' * 4))

            for parameter in parameters:
                name = self.normalize_names(parameter["name"])
                if name == 'body':
                    if "data" in parameter.keys():
                        data = parameter["data"]
                        for item in data:
                            name = self.normalize_names(item["name"])
                            if str(item['type']) in self.param_types.keys():
                                self.get_parameter_option(item, text, name, category["name"] + "#" + method_name)
                else:
                    self.get_parameter_option(parameter, text, name, category["name"] + "#" + method_name)

            text.append('{}}}'.format(' ' * 2))
            text.append('{}'.format(' ' * 2))
            text.append('{}'.format(' ' * 2))
            return '\n'.join(text)
        else:
            return '\n//excluded ' + method_name + '\n'
        '''

    def get_parameter_option(self, parameter, text, name, category):
        if self.check_ignore_subcommand(category, name):
            description = parameter["description"]
            required = parameter["required"]
            type_param = self.param_types[str(parameter['type'])]
            self.append_parameter(text, self.to_kebab_case(parameter["name"].replace('.', '-')), description,
                                  str(required).lower())
            append_text(text, '{}public {} {}; '.format((' ' * 8), type_param, name, parameter["name"]), 8)
            text.append('{}'.format(' ' * 4))
        else:
            text.append('// Exclusion ' + name)

    def check_ignore_command(self, param, method_name):
        res = True
        if param in self.exclude_commands.keys() and method_name in self.exclude_commands[param]:
            res = False
        return res

    def to_kebab_case(self, name):
        name = re.sub('(.)([A-Z][a-z]+)', r'\1-\2', name)
        name = re.sub('__([A-Z])', r'-\1', name)
        name = re.sub('([a-z0-9])([A-Z])', r'\1-\2', name)
        return name.lower()

    def get_file_name(self, category):
        return self.categories[self.get_category_name(category)] + "CommandExecutor.java"

    def get_method_name(self, endpoint, category):
        method_name = super().get_method_name(endpoint, category)
        # Convert to cammel case
        method_name = method_name.replace('_', ' ').title().replace(' ', '')
        return method_name[0].lower() + method_name[1:]

    def get_parameter_description(self, parameter):
        return "."

    def get_method_parameters(self, endpoint):
        return endpoint["parameters"]

    def get_parameter_type(self, parameter):

        return parameter["type"]

    def append_command(self, array, name, description):
        if '"' in description:
            description = description.replace('"', '\\"')
        res = (' ' * 4) + '@Parameters(commandNames = {"' + name + '"}, commandDescription = "' + description + '")'
        if len(res) <= 140:
            array.append(res)
        else:
            res = (' ' * 4) + '@Parameters(commandNames = {"' + name + '"}, commandDescription = "'
            aux = (' ' * 4) + '@Parameter(commandNames = {"' + name + '"}, commandDescription = "'
            for word in description.split(' '):
                aux += word + ' '
                if len(aux) > 137:
                    array.append(res + '"')
                    res = (' ' * 30) + '+ "' + word + ' '
                    aux = res
                else:
                    res += word + ' '
            array.append(res[:-1] + '")')

    def append_parameter(self, array, name, description, required):
        if '"' in description:
            description = description.replace('"', '\\"')

        res = (
                      ' ' * 8) + '@Parameter(names = {"--' + name + '"}, description = "' + description + '", required = ' + required + \
              ', arity = 1)'
        if len(res) <= 140:
            array.append(res)
        else:
            res = (' ' * 8) + '@Parameter(names = {"--' + name + '"}, description = "'
            aux = (' ' * 8) + '@Parameter(names = {"--' + name + '"}, description = "'
            for word in description.split(' '):
                aux += word + ' '
                if len(aux) > 137:
                    array.append(res + '"')
                    res = (' ' * 30) + '+ "' + word + ' '
                    aux = res
                else:
                    res += word + ' '

            if len(res + '", required = ' + required + ', arity = 1)') > 140:
                array.append(res[:-1] + '",')
                array.append((' ' * 30) + 'required = ' + required + ', arity = 1)')
            else:
                array.append(res[:-1] + '", required = ' + required + ', arity = 1)')

    def get_valid_parameter_type(self, my_type, my_import):
        if my_type.endswith(';'):
            my_type = my_type[:-1]

        if '$' in my_type:
            my_type = my_type.replace('$', '.')
        if '$' in my_import:
            my_import = my_import.replace('$', '.')

        if my_type == '' or my_type == 'Map':
            my_type = 'ObjectMap'
        else:
            self.type_imports[my_import] = my_import
        self.java_types.add(my_type)

        return my_type

    def normalize_names(self, name):
        res = name
        if name == "default":
            res = "defaultParam"
        if '_' in name:
            res = ''.join(word.title() for word in name.split('_'))
        if '.' in name:
            res = ''.join(word.title() for word in name.split('.'))
        res = res[0].lower() + res[1:]
        return res

    def get_as_class_name(self, attribute):
        return attribute[0].upper() + attribute[1:]

    def check_ignore_subcommand(self, param, method_name):
        res = True
        if param in self.exclude_command_params.keys() and method_name in self.exclude_command_params[param]:
            res = False
        return res

    def get_GET_method_name(self, category, endpoint):
        method_name = self.get_method_name(endpoint, category).lower()
        text = []
        text.append('        private RestResponse<{}> {}() throws ClientException {{'.format(self.categories[category['name']],
                                                                                             method_name))
        text.append('        logger.debug("Executing {} in {} command line");'.format(method_name, self.categories[category['name']]))
        text.append('')
        text.append('        {}CommandOptions.{}CommandOptions commandOptions = {}CommandOptions.{}CommandOptions;'.format(
            self.categories[category['name']], method_name.title(), category['name'].lower(), method_name))
        text.append('')
        text.append('        ObjectMap params = new ObjectMap({}DBAdaptor.QueryParams.STUDY.key(), commandOptions.study);'.format(
            self.categories[category['name']]))
        text.append('')
        parameters = self.get_method_parameters(endpoint)
        text.append('        SampleCreateParams {}Params = new SampleCreateParams()'.format(method_name))
        for param in parameters:
            name = self.normalize_names(param["name"])
            if name == 'body':
                if "data" in param.keys():
                    data = param["data"]
                    for item in data:
                        name = self.normalize_names(item["name"])
                        if str(item['type']) in self.param_types.keys():
                            if param != parameters[-1]:
                                text.append('                .set{}(commandOptions.{})'.format(name[0].title() + name[1:], name))
                            else:
                                text.append('                .set{}(commandOptions.{});'.format(name[0].title() + name[1:], name))
            else:
                if param != parameters[-1]:
                    text.append('                .set{}(commandOptions.{})'.format(name[0].title() + name[1:], name))
                else:
                    text.append('                .set{}(commandOptions.{});'.format(name[0].title() + name[1:], name))

        text.append('')
        text.append(
            '        return openCGAClient.get{}Client().{}({}Params, params);'.format(self.categories[category['name']], method_name,
                                                                                      method_name))
        text.append('    }')
        return '\n'.join(text)


def remove_redundant_imports(imports):
    to_remove = []
    for i in range(len(imports) - 1):
        for j in range(i + 1, len(imports)):
            if imports[i][:-1] + "." in imports[j][:-1]:
                to_remove.append(imports[j])
            elif imports[j][:-1] + "." in imports[i][:-1]:
                to_remove.append(imports[i])

    for my_import in to_remove:
        imports.remove(my_import)

    return imports


def append_text(array, string, sep):
    _append_text(array, string, sep, sep, False)


def append_comment_text(array, string, sep, sep2=None):
    _append_text(array, string, sep, sep if sep2 is None else sep2, True)


def _append_text(array, string, sep, sep2, comment):
    if len(string) <= 140:
        array.append(string)
    else:
        res = ''
        for word in string.split(' '):
            res += word + ' '
            if len(res) > 140:
                array.append(res + '"+')
                res = (' ' * 30) + ' "'
        array.append(res)


def main():
    # Getting arg parameters
    client_generator = ExecutorCliGenerator()

    # client_generator = JavaClientGenerator(args.server_url, args.output_dir)
    client_generator.create_rest_clients()


if __name__ == '__main__':
    sys.exit(main())
