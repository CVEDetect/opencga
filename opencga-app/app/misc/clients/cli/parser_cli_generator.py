#!/usr/bin/env python3
# importing date class from datetime module
import os
import re
import sys
# importing date class from datetime module
from datetime import date

currentdir = os.path.dirname(os.path.realpath(__file__))
parentdir = os.path.dirname(currentdir)
print(parentdir)
sys.path.insert(0, parentdir)

import rest_client_generator


class ParserCliGenerator(rest_client_generator.RestClientGenerator):

    def __init__(self):
        super().__init__()
        self.normalized_objects_map = {
            'Map': 'ObjectMap'}

        self.java_types = set()
        self.type_imports = {
            'java.util.Map;': 'org.opencb.commons.datastore.core.ObjectMap;'
        }
        self.param_types = {
            'string': 'String',
            'object': 'Object',
            'integer': 'int',
            'int': 'int',
            'map': 'ObjectMap',
            'boolean': 'boolean',
            'enum': 'String',
            'long': 'Long',
            'java.lang.String': 'String',
            'java.lang.Boolean': 'boolean',
            'java.lang.Integer': 'int',
            'java.lang.Long': 'int',
            'java.lang.Short': 'int',
            'java.lang.Double': 'int',
            'java.lang.Float': 'int'
        }
        self.output_dir = self.executors_output_dir
        self.imports = []

    def get_imports(self):
        headers = []
        headers.append('/*')
        headers.append('* Copyright 2015-{} OpenCB'.format(date.today().year))
        headers.append('*')
        headers.append('* Licensed under the Apache License, Version 2.0 (the "License");')
        headers.append('* you may not use this file except in compliance with the License.')
        headers.append('* You may obtain a copy of the License at')
        headers.append('*')
        headers.append('*     http://www.apache.org/licenses/LICENSE-2.0')
        headers.append('*')
        headers.append('* Unless required by applicable law or agreed to in writing, software')
        headers.append('* distributed under the License is distributed on an "AS IS" BASIS,')
        headers.append('* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.')
        headers.append('* See the License for the specific language governing permissions and')
        headers.append('* limitations under the License.')
        headers.append('*/')
        headers.append('')
        headers.append('package ' + self.parser_package + ';')
        headers.append('')
        headers.append('import com.beust.jcommander.JCommander;')
        headers.append('import org.opencb.commons.utils.CommandLineUtils;')
        headers.append('import org.opencb.opencga.app.cli.CliOptionsParser;')
        headers.append('import org.opencb.opencga.app.cli.GeneralCliOptions;')
        headers.append('import org.opencb.opencga.app.cli.admin.AdminCliOptionsParser;')
        headers.append('import org.opencb.opencga.core.common.GitRepositoryState;')
        headers.append('')
        headers.append('import java.util.*;')
        headers.append('')
        headers.append('import ' + self.options_package + '.*;')
        autogenerated_message = ['/*']
        for text in self.get_autogenerated_message():
            if text == '':
                autogenerated_message.append('*')
            else:
                autogenerated_message.append('* ' + text)
        autogenerated_message.append('*/')

        return '\n'.join(headers) + '\n\n\n' + '\n'.join(autogenerated_message)

    def get_class_definition(self, category):
        self.java_types = set()
        self.imports = []

        text = []
        text.append('')
        text.append('public class OpencgaCliOptionsParser extends CliOptionsParser {')
        text.append('')
        text.append('{}private final GeneralCliOptions.CommonCommandOptions commonCommandOptions;'.format((' ' * 4)))
        cats = list(self.categories.keys())
        for category in self.json_resource:
            if category["name"] in cats:
                text.append('{}private final {}CommandOptions {}CommandOptions;'.format((' ' * 4), self.categories[self.get_category_name(
                    category)],
                                                                                        self.get_as_variable_name(self.categories[
                                                                                                                      self.get_category_name(
                                                                                                                          category)])))
        text.append('')
        text.append('{}enum OutputFormat {{IDS, ID_CSV, NAME_ID_MAP, ID_LIST, RAW, PRETTY_JSON, PLAIN_JSON}}'.format((' ' * 4)))
        text.append('')
        text.append('{}public OpencgaCliOptionsParser() {{'.format((' ' * 4)))
        text.append('')
        text.append('{}jCommander.setExpandAtSign(false);'.format((' ' * 8)))
        text.append('{}commonCommandOptions = new GeneralCliOptions.CommonCommandOptions();'.format((' ' * 8)))

        for category in self.json_resource:
            if category["name"] in cats:
                text.append('')
                text.append('{}{}CommandOptions = new {}CommandOptions(commonCommandOptions, jCommander);'.format((' ' * 8),
                                                                                                                  self.get_as_variable_name(
                                                                                                                      self.categories[
                                                                                                                          self.get_category_name(
                                                                                                                              category)]),
                                                                                                                  self.categories[
                                                                                                                      self.get_category_name(
                                                                                                                          category)]))
                text.append('{}jCommander.addCommand("{}", {}CommandOptions);'.format(' ' * 8, self.get_category_path(category),
                                                                                      self.get_as_variable_name(self.categories[
                                                                                                                    self.get_category_name(
                                                                                                                        category)])))
                text.append('{}JCommander {}SubCommands = jCommander.getCommands().get("{}");'.format(' ' * 8,
                                                                                                      self.get_as_variable_name(
                                                                                                          self.categories[
                                                                                                              self.get_category_name(
                                                                                                                  category)]),
                                                                                                      self.get_category_path(
                                                                                                          category)))
                for endpoint in category["endpoints"]:
                    text.append(
                        '{}{}SubCommands.addCommand("{}", {}CommandOptions.{}CommandOptions);'.format((' ' * 8), self.get_as_variable_name(
                            self.categories[self.get_category_name(category)]), self.to_kebab_case(
                            self.get_method_name(endpoint, category)), self.get_as_variable_name(
                            self.categories[self.get_category_name(category)]), self.get_as_class_name(
                            self.get_method_name(endpoint, category))))

        text.append('    }')

        return '\n'.join(text)

    def get_class_end(self):
        return '}\n'

    def get_method_definition(self, category, endpoint):
        text = []
        cats = list(self.categories.keys())
        for category in self.json_resource:
            if category["name"] in cats:
                text.append(' ' * 4)
                text.append('{}public {}CommandOptions get{}CommandOptions() {{'.format((' ' * 4), self.categories[
                    self.get_category_name(category)], self.categories[self.get_category_name(category)]))

                text.append('{}return {}CommandOptions;'.format((' ' * 8), self.get_as_variable_name(
                    self.categories[self.get_category_name(category)])))
                text.append('{}}}'.format((' ' * 4)))
        '''
        public UserCommandOptions getUsersCommandOptions() {
        return usersCommandOptions;
    }
        '''

        return '\n'.join(text)

    def get_parameter_option(self, parameter, text, name, category):
        if self.check_ignore_subcommand(category, name):
            description = parameter["description"]
            required = parameter["required"]
            type_param = self.param_types[str(parameter['type'])]
            self.append_parameter(text, self.to_kebab_case(parameter["name"].replace('.', '-')), description,
                                  str(required).lower())
            append_text(text, '{}public {} {}; '.format((' ' * 8), type_param, name, parameter["name"]), 8)
            text.append('{}'.format(' ' * 4))
        else:
            text.append('// Exclusion ' + name)

    def check_not_ignored_command(self, param, method_name):
        res = True
        if param in self.exclude_commands.keys() and method_name in self.exclude_commands[param]:
            res = False
        return res

    def to_kebab_case(self, name):
        name = re.sub('(.)([A-Z][a-z]+)', r'\1-\2', name)
        name = re.sub('__([A-Z])', r'-\1', name)
        name = re.sub('([a-z0-9])([A-Z])', r'\1-\2', name)
        return name.lower()

    def get_file_name(self, category):
        return "OpencgaCliOptionsParser.java"

    def get_method_name(self, endpoint, category):
        method_name = super().get_method_name(endpoint, category)
        # Convert to cammel case
        method_name = method_name.replace('_', ' ').title().replace(' ', '')
        return method_name[0].lower() + method_name[1:]

    def get_parameter_description(self, parameter):
        return "."

    def get_method_parameters(self, endpoint):
        return endpoint["parameters"]

    def get_parameter_type(self, parameter):
        return parameter["type"]

    def get_valid_parameter_type(self, my_type, my_import):
        if my_type.endswith(';'):
            my_type = my_type[:-1]

        if '$' in my_type:
            my_type = my_type.replace('$', '.')
        if '$' in my_import:
            my_import = my_import.replace('$', '.')

        if my_type == '' or my_type == 'Map':
            my_type = 'ObjectMap'
        else:
            self.type_imports[my_import] = my_import
        self.java_types.add(my_type)

        return my_type

    def normalize_names(self, name):
        res = name
        if name == "default":
            res = "defaultParam"
        if '_' in name:
            res = ''.join(word.title() for word in name.split('_'))
        if '.' in name:
            res = ''.join(word.title() for word in name.split('.'))
        res = res[0].lower() + res[1:]
        return res

    def get_as_class_name(self, attribute):
        return attribute[0].upper() + attribute[1:]

    def check_ignore_subcommand(self, param, method_name):
        res = True
        if param in self.exclude_command_params.keys() and method_name in self.exclude_command_params[param]:
            res = False
        return res

    def get_query_params(self, endpoint, mandatory):
        query_params_no_mandatory = []
        for parameter in endpoint["parameters"]:
            if parameter["param"] == "query" and parameter["required"] == mandatory:
                if str(parameter['type']) in self.param_types.values():
                    query_params_no_mandatory.append(parameter)
        return query_params_no_mandatory

    def normalize_object(self, param):
        if param in self.normalized_objects_map.keys():
            return self.normalized_objects_map[param]
        return param

    def get_body_params(self, endpoint):
        parameters = self.get_method_parameters(endpoint)
        body_params = []
        for param in parameters:
            name = self.normalize_names(param["name"])
            if name == 'body':
                if "data" in param.keys():
                    data = param["data"]
                    for item in data:
                        if str(item['type']) in self.param_types.values():
                            body_params.append(item)
        return body_params

    def get_object_name(self, param, method_name):
        return param.title() + '' + method_name[0].title() + method_name[1:]

    def get_command_options_path_params(self, endpoint):
        path_params = self.get_path_params(endpoint)
        res = []
        for param in path_params:
            res.append("commandOptions." + param)

        return res

    def get_return_query_params(self, endpoint):
        res = []
        query_params = self.get_query_params(endpoint, True)
        if query_params:
            if self.get_path_params(endpoint):
                res.append(" ")
                for param in query_params:
                    res.append("commandOptions.{}.name()".format(param["name"]))
        return res

    def get_return_body_params(self, exists_body_params, object_name, endpoint):
        res = ""
        if exists_body_params:
            if self.get_query_params(endpoint, True) or self.get_path_params(endpoint):
                res = ", " + str(object_name).lower() + "Params"
            else:
                res = str(object_name).lower() + "Params"
        return res

    def get_return_query_params_no_mandatory(self, exists_query_params, exists_body_params, endpoint):
        res = ""
        if exists_query_params:
            if self.get_query_params(endpoint, True) or self.get_path_params(endpoint) or exists_body_params:
                res = ", queryParams"
            else:
                res = "queryParams"
        return res

    def create_parser(self):
        text = []
        text.append(self.get_class_definition(""))
        # self.parse_resources("", "")

        # Add the abstract methods implementation
        with open("parser_abstract_methods.template", 'r') as handler:
            text.append(handler.read())

        text.append(self.get_method_definition("", ""))

        text.append(self.get_class_end())

        # Now, we put in the first position the imports.
        text.insert(0, self.get_imports())

        # Choose the file name to be created
        file_name = self.get_file_name("")
        self.LOG(
            'Creating ' + os.path.join("/workspace/opencga/opencga-app/src/main/java/org/opencb/opencga/app/cli/main/", file_name) + '...')
        with open(os.path.join("/workspace/opencga/opencga-app/src/main/java/org/opencb/opencga/app/cli/main/", file_name), 'w') as fhand:
            fhand.write('\n'.join(text))


def remove_redundant_imports(imports):
    to_remove = []
    for i in range(len(imports) - 1):
        for j in range(i + 1, len(imports)):
            if imports[i][:-1] + "." in imports[j][:-1]:
                to_remove.append(imports[j])
            elif imports[j][:-1] + "." in imports[i][:-1]:
                to_remove.append(imports[i])

    for my_import in to_remove:
        imports.remove(my_import)

    return imports


def append_text(array, string, sep):
    _append_text(array, string, sep, sep, False)


def append_comment_text(array, string, sep, sep2=None):
    _append_text(array, string, sep, sep if sep2 is None else sep2, True)


def _append_text(array, string, sep, sep2, comment):
    if len(string) <= 140:
        array.append(string)
    else:
        res = ''
        for word in string.split(' '):
            res += word + ' '
            if len(res) > 140:
                array.append(res + '"+')
                res = (' ' * 30) + ' "'
        array.append(res)


def main():
    # Getting arg parameters
    client_generator = ParserCliGenerator()

    # client_generator = JavaClientGenerator(args.server_url, args.output_dir)
    client_generator.create_parser()


if __name__ == '__main__':
    sys.exit(main())
